    Author: Serge Aleynikov <saleyn(at)gmail(dot)com>
    Status: Draft
    Type: Standards Track
    Erlang-Version: R24
    Created: 09-Jun-2021
    Post-History:
****
EEP 57: Extending the syntax of patterns with alternative matches
----



Abstract
========

Currently Erlang only supports a single match in expression when defining a
pattern match in case, recieve expressions, function clauses, lambdas,
try-of, and try-catch, the generators in list and bit-string comprehensions,
and function arguments.

This proposal extends the syntax to allow multiple alternative matches to
share the same body or to be matched against a right hand side expression.



Specification
=============

Currently, a match in a case, receive, try-of expression looks similar to
this syntax:
```
    case I of
      1 -> less_than_three;
      2 -> less_than_three;
      3 -> less_than_ten;
      _ -> other
    end.
```
This should be changed to allow:
```
    case I of
      1 | 2 -> less_than_three;
      3     -> less_than_ten;
      _     -> other
    end.
```
Similarly, a function or an expression match looks like:
```
foo(1) -> ok;
foo(2) -> ok;
foo(N) -> other.
```

More generally, a pattern in a case, receive, try-of expression, lambda,
or a patten match, should be extended from the following:
```
    case Expr of
        Pattern1 [when GuardSeq1] ->
            Body1;
        ...;
        PatternN [when GuardSeqN] ->
            BodyN
    end

    receive
        Pattern1 [when GuardSeq1] ->
            Body1;
        ...;
        PatternN [when GuardSeqN] ->
            BodyN
    after ExprT ->
        BodyT
    end

    try Exp [of
        Pattern1 [when GuardSeq1] ->
            Body1;
        ...;
        PatternN [when GuardSeqN] ->
            BodyN
        ]
    catch
        Class1:ExceptionPattern1[:Stacktrace] [when ExceptionGuardSeq1] ->
            ExceptionBody1;
        ...;
        ClassN:ExceptionPatternN[:Stacktrace] [when ExceptionGuardSeqN] ->
            ExceptionBodyN
    end

    Res = ExprF(Expr1,...,ExprN)

```
to support the following syntax:
```
    case Expr of
        Pattern1A |
        Pattern1B |
        ...
        Pattern1N [when GuardSeq1] ->
            Body1;
        ...;
        PatternNA |
        PatternNB |
        ...
        PatternNN [when GuardSeqN] ->
            BodyN
    end

    receive
        Pattern1A |
        Pattern1B |
        ...
        Pattern1N [when GuardSeq1] ->
            Body1;
        ...;
        PatternNA |
        PatternNB |
        ...
        PatternNN [when GuardSeqN] ->
            BodyN
    after ExprT ->
        BodyT
    end

    try Exp [of
        Pattern1A |
        Pattern1B |
        ...
        Pattern1N [when GuardSeq1] ->
            Body1;
        ...;
        PatternNA |
        PatternNB |
        ...
        PatternNN [when GuardSeqN] ->
            BodyN
        ]
    catch
        Class1:ExceptionPattern1A|
               ExceptionPattern2A| ...
               ExceptionPatternNA[:StackTrace] [when ExceptionGuard1A] ->
            ExceptionBodyE1;
        ClassN:ExceptionPattern1N|
               ExceptionPattern2N| ...
               ExceptionPatternNN[:StackTrace] [when ExceptionGuardNN] ->
            ExceptionBodyEN
    end

    Res1 | Res2 | ... | ResN =
      ExprF(Expr1, Expr2, ... , ExprN)

    ExprF1(Expr1A1 | Expr1A2 | ... | Expr1AN, ...,
           Expr1N1 | Expr1N2 | ... | Expr1NN) [when GuardSeq1] -> Body1;
    ExprFN(ExprNA1 | ExprNA2 | ... | ExprNAN, ...,
           ExprNN1 | ExprNN2 | ... | ExprNNN) [when GuardSeq1] -> Body1

```

A variable can only be used in the guards if its bound in all alternative
patterns. That is, the following is allowed:
```
    case X of
        {A, 0} | {0, A} when A > 0 -> ok
    end

    {A, 1} | {A, 2} = foo()

    bar({A, 1} | {A, 2}) -> true
```
and the following is not allowed:
```
    case X of
        {A, 0} |
        {0, B} when B > 0 -> ok
    end

    {A, 1} | {B, 2} = foo()

    bar({A, 1} | {B, 2}) -> true
```
The cases shown above would produce a compilation error in the form:
```
Error: alternative patterns must have the same variables defined
```

In cases when the use of `|` becomes ambiguous, such as when using
in combination with cons in lists, the precedence is given to the
legacy cons syntax, and parenthesis can be used to disambiguate the
alternative match expressions:
```
    case X of
      [3 | T]     -> {ok, T};
      [1 | 2 | T] -> error;   % Compiler error: ambiguous use of pipe symbol
      [(1|2) | T] ->
        % Alternative matches, of lists' head being 1 or 2
        {ok, T}
    end

    [(1|2) | T] = check_head_version(L)
```


Rationale
=========

Implementation of this proposal would lead to a more
convenient way to code redundant matching clauses, and
would eliminate code duplication.

Example of where this could be useful can be found in
many places in the existing OTP code. E.g. ssl_logger.erl:
```
    case logger:compare_levels(Level, debug) of
        lt ->
            ?LOG_DEBUG(#{direction => Direction,
                         protocol => Protocol,
                         message => Message},
                       #{domain => [otp,ssl,Protocol]});
        eq ->
            ?LOG_DEBUG(#{direction => Direction,
                         protocol => Protocol,
                         message => Message},
                       #{domain => [otp,ssl,Protocol]});
        _ ->
            ok
    end.

    case logger:compare_levels(Level, notice) of
        lt ->
            ?LOG_NOTICE(Report);
        eq ->
            ?LOG_NOTICE(Report);
        _ ->
            ok
    end.
```

Additionally, this syntax extension leads to consistency between
function spec definitions and their implementations:
```
    -spec f(foo|bar) -> ok.
    f(foo|bar) -> ok.
```



Backwards Compatibility
=======================

Any code that uses the legacy implementation of the case and receive
expressions will continue to work as it does today and produce
the same results.



Reference Implementation
========================

As an implementation suggestion, the AST can be rewritten by to duplicate
the alternative patterns containing the pipe, so the case of
``X of lt | gt -> ok end`` becomes ``case X of lt -> ok; gt -> ok end``.
For match expressions, it could rewrite ``lt | gt = compare(A, B)``
to a case statement ``case compare(A, B) of lt -> lt; gt -> gt end``,
and function argument matches ``foo(lt | gt, a | b) -> true`` would become:
```
foo(lt, a) -> true;
foo(gt, a) -> true;
foo(lt, b) -> true;
foo(gt, b) -> true
```


Copyright
=========

This document has been placed in the public domain.



[EmacsVar]: <> "Local Variables:"
[EmacsVar]: <> "mode: indented-text"
[EmacsVar]: <> "indent-tabs-mode: nil"
[EmacsVar]: <> "sentence-end-double-space: t"
[EmacsVar]: <> "fill-column: 70"
[EmacsVar]: <> "coding: utf-8"
[EmacsVar]: <> "End:"
