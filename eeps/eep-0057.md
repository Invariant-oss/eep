    Author: Serge Aleynikov <saleyn(at)gmail(dot)com>
    Status: Draft
    Type: Standards Track
    Erlang-Version: R24
    Created: 09-Jun-2021
    Post-History:
****
EEP 57: Extending the syntax of patterns in case and receive expressions
----



Abstract
========

Currently Erlang only supports a list of [independent
patterns](https://erlang.org/doc/reference_manual/expressions.html#case)
that are sequentially matched against the result of evaluating the case
or receive expression, which return a pattern body.

This proposal extends the syntax to allow multiple matches to
share the same body.



Specification
=============

Currently, a case expression looks like this:
```
    case I of
      1 -> less_than_three;
      2 -> less_than_three;
      3 -> less_than_ten;
      _ -> other
    end.
```
This should be changed to allow:
```
    case I of
      1 | 2 -> less_than_three;
      3     -> less_than_ten;
      _     -> other
    end.
```
More generally, a pattern in a case or receive expression, should be
extended from the following:
```
    case Expr of
        Pattern1 [when GuardSeq1] ->
            Body1;
        ...;
        PatternN [when GuardSeqN] ->
            BodyN
    end

    receive
        Pattern1 [when GuardSeq1] ->
            Body1;
        ...;
        PatternN [when GuardSeqN] ->
            BodyN
    after ExprT ->
        BodyT
    end

```
to support the following syntax:
```
    case Expr of
        Pattern1A |
        Pattern1B |
        ...
        Pattern1N [when GuardSeq1] ->
            Body1;
        ...;
        PatternNA |
        PatternNB |
        ...
        PatternNN [when GuardSeqN] ->
            BodyN
    end

    receive
        Pattern1A |
        Pattern1B |
        ...
        Pattern1N [when GuardSeq1] ->
            Body1;
        ...;
        PatternNA |
        PatternNB |
        ...
        PatternNN [when GuardSeqN] ->
            BodyN
    after ExprT ->
        BodyT
    end

```

A variable can only be used in the guards if its bound in all alternative
patterns. That is, the following is allowed:
```
    case X of
        {A, 0} | {0, A} when A > 0 -> ok
    end
```
and the following is not allowed:
```
    case X of
        {A, 0} |
        {0, B} when B > 0 -> ok
    end
```
The case above would produce a compilation error in the form:
```
Error: alternative patterns must have the same variables defined
```

Rationale
=========

Implementation of this proposal would lead to a more
convenient way to code redundant matching clauses, and
would eliminate code duplication.

Example of where this could be useful can be found in
many places in the existing OTP code. E.g. ssl_logger.erl:

    case logger:compare_levels(Level, debug) of
        lt ->
            ?LOG_DEBUG(#{direction => Direction,
                         protocol => Protocol,
                         message => Message},
                       #{domain => [otp,ssl,Protocol]});
        eq ->
            ?LOG_DEBUG(#{direction => Direction,
                         protocol => Protocol,
                         message => Message},
                       #{domain => [otp,ssl,Protocol]});
        _ ->
            ok
    end.

    case logger:compare_levels(Level, notice) of
        lt ->
            ?LOG_NOTICE(Report);
        eq ->
            ?LOG_NOTICE(Report);
        _ ->
            ok
    end.



Backwards Compatibility
=======================

Any code that uses the legacy implementation of the case
expression will continue to work as it does today and produce
the same results.



Reference Implementation
========================

None.



Copyright
=========

This document has been placed in the public domain.



[EmacsVar]: <> "Local Variables:"
[EmacsVar]: <> "mode: indented-text"
[EmacsVar]: <> "indent-tabs-mode: nil"
[EmacsVar]: <> "sentence-end-double-space: t"
[EmacsVar]: <> "fill-column: 70"
[EmacsVar]: <> "coding: utf-8"
[EmacsVar]: <> "End:"
