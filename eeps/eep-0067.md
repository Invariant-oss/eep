    Author: Marko Minđek <marko.mindek(at)invariant(dot)hr>
    Status: Draft
    Type: Standards Track
    Created: 02-Jan-2024
    Erlang-Version: OTP-27
    Post-History:
****
EEP XXX: Internal export
----

Abstract
========

TODO - princip internal_exporta, enkapsulacija
TODO - link na EEP05
This EEP intorduces a new directive called `internal_export` which enables
formal semantic separation of function exports.  This EEP is mostly ispired
by EEP-05.

Rationale
=========

You want to internally export a function when function is either:
1. callback function
2. meant to be called only from within the current application
3. test-only function

TODO - problemi, sučelje aplikacije, dokumentacija
TODO - broj nedokumentiranih modula, broj nedokumentiranih, ali exportanih funkcija
TODO - trenutno stanje s komentarima iznad exporta
EEP submissions come in a wide variety of forms, not all adhering to the
format guidelines set forth below.  Use this template, in conjunction with
the content guidelines in [EEP 1][], to ensure that your EEP submission
won't get automatically rejected because of form.

Specification
=============
TODO: current app i svi njezini dependenciji

EEP-05 Modifications
====================

TODO linkovi na EEP-05
Although idea is the same, there are few key differences in design and implementation between this EEP and EEP-05:
1. Application-based approach
There is an open question whether to export functions to modules or to applications. Exporting to modules is currently proposed in EEP-05.

Although module-based approach is straightforward, it has 2 drawbacks:
1. Maintainance - you have to manually intervene after module is added or renamed.
2. Exporting to behaviors - you would expect that
    ```
    -export_to(gen_server, [init/1, handle_cast/2, handle_call/3]).
    ```
would work.
It would be very convenient to export callbacks this way instead of
    ```
    %% gen_server API
    -export([init/1, handle_cast/2, handle_call/3]).
    ```
, but this notation is actually wrong, because calls to `gen_server` callbacks are actually done in `gen` module, not `gen_server`.  User shouldn't even think about that implementation detail, let alone writing code dependent on it.

2. Implicit scope
TODO objasniti scope, citat s "flotila of modules"

Currently, in any codebase you can find comment-based attempt to clarify module/application API, e.g.:
```erlang
%% gen_server
-export([init/1, handle_cast/2, handle_call/3, code_change/3]).
%% system calls
-export(...).
%% test-only
-export(...).
%% API
-export(...).
%% internal exports
-export(...).
```
.  This of course works, but comment-based semantical separation of exports limits any usage of code analysis tools.  Can we do better?

In EEP-05, responsibility of declaring export scope is on the programmer. This may result in convenient, more semantically valuable code, like:
```erlang
-export_to([mod_x, mod_y], [f_1/1, f_2/0]).
```
. It cleary denotes what is the purpose of some particular export, i.e. which modules can call them.  Notice that this is only convenient when limiting function usage to the application itself (conventionally called *internal exports*) - it is mentioned before that this approach is not appropriate when exporting functions to behavior modules.

This brings up a question: how much control do we really need/want?  Purpose of this EEP is to limit ways users can missuse applications/modules.  **Missuage doesn't come from within the application itself, or from its dependency applications, but from its users!** I.e. besides private and global, there is a need for *internal* export scope.

There is no need for user to specify the scope manually as it can be determined at compile-time: internally exported function can be called from the application where it is declared or from any of its dependency applications.

Implicit scoping is not as semantically valuable as declarative one, but it does the main task; **it separates application/module API from internal stuff**.

3. Syntax

Attribute named `export_to` seems completely logic when used with declarative scoping, but with implicition scoping it is unclear to what *_to* reffers.  Name `internal_export` is proposed instead of `export_to`. Notice that it only has one argument with the same syntax rules as for `export`. 

4. Implementation




Reference Implementation
========================
TODO - link na PR, možda opisati razlike

Backward compatibility
======================

When referencing an external web page in the body of an EEP, you
should include the title of the page in the text, with a footnote
reference to the URL.  Do not include the URL in the body text of the
EEP.  E.g:

    Refer to the [Erlang Language web site][1] for more details.

    :

    [1]: http://www.erlang.org
        "Erlang Programming Language"

Footnote reference definitions should be placed second last in the
document, right before the "Copyright" section and the Emacs magic.
Note that these references are invisible in the by [Markdown][]
generated HTML.

When referring to another EEP, include the EEP number in the body text
using an implicit link name footnote, such as `[EEP 1][]`.  The title
may optionally appear.  The footnote body should include the EEP's
title and author, and it should refer to its URL.

> NOTE: The URL is relative to the current URL and the build
> tools will fix it to point to the .html file.
>

Example:

    Refer to [EEP 1][] for more information about EEP style

    :

    [EEP 1]: eep-0001.md
        "EEP 1, EEP Purpose and Guidelines, Gustafsson"

EEP numbers in URLs must be padded with zeros from the left, so as to
be exactly 4 characters wide, however EEP numbers in the text are
never padded.

[eep.md]: eep-0033.md
    "EEP Source"

[EEP 1]: eep-0001.md
    "EEP Purpose and Guidelines, Gustafsson"

[PEP 9]: http://www.python.org/dev/peps/pep-0009/
    "Sample Plaintext PEP Template, Warsaw"

[Markdown]: http://daringfireball.net/projects/markdown/
   "Markdown Home Page"

[OPL]: http://www.opencontent.org/openpub/
    "Open Publication License"

[CCA3.0]: http://creativecommons.org/licenses/by/3.0/
    "Creative Commons Attribution 3.0 License"

[Emacs turd]: http://www.gnu.org/software/emacs/manual/html_node/emacs/Specifying-File-Variables.html
    "Specifying local file variables for Emacs"

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.

TODOS:
Provjeriti formatting, broj znakova u redu, tabovi, dvostruki razmak.
Generirati HTML, Provjeriti

[EmacsVar]: <> "Local Variables:"
[EmacsVar]: <> "mode: indented-text"
[EmacsVar]: <> "indent-tabs-mode: nil"
[EmacsVar]: <> "sentence-end-double-space: t"
[EmacsVar]: <> "fill-column: 70"
[EmacsVar]: <> "coding: utf-8"
[EmacsVar]: <> "End:"
[VimVar]: <> " vim: set fileencoding=utf-8 expandtab shiftwidth=4 softtabstop=4: "
