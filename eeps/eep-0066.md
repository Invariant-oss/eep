    Author: Raimo Niskanen <raimo(at)erlang(dot)org>
    Status: Draft
    Type: Standards Track
    Created: 25-Sep-2023
    Erlang-Version: OTP-27
    Post-History:
****
EEP 66: Sigils for String Literals
----

Abstract
========

This EEP proposes Sigils for string literals very much like
[Elixir Sigils][1].  The chief reason is to facilitate other suggested
language features,  many of which exists in Elixir under the umbrella of
[Sigils][1], such as:

* Binary Strings; `unicode:unicode_binary()`
* Regular Expression Syntax
* Choice of string delimiters
* Verbatim Strings
* [String Interpolation Syntax][2], or Variable Interpolation

Rationale
=========

Many existing suggestions listed in the [Abstract][]
use a prefix before a normal erlang string such as:

    u"For UTF-8 encoded binary strings"

or

    bf"For UTF-8 encoded binary with interpolation formatting: ~foo()~"

This EEP suggests using the same or very similar syntax as in Elixir
for [Sigils][3] on literal strings to avoid syntactical problems with
simple prefixes, and to not make these sibling languages deviate
too much without good reason:

    ~s"For UTF-8 encoded binary with interpolation formatting: ~foo()~"

Design Decisions
----------------

In the following text double angle quotation marks are used to
highlight source code characters in a paragraph.  For example:
«`.`» means the dot character (full stop).

### Erlang Language Structure (Tokenizer and Parser)

The Erlang programming language is built according to a traditional
tokenizer+parser+compiler model.

The tokenizer a.k.a scanner a.k.a lexer scans the source code
character sequence and converts into a sequence of Tokens,
like atom, variable, string, integer, reserved word,
punctuation character or operator:
«`atom`», «`Variable`», «`"string"`», «`123`», «*case*», «`:`» and «`++`».

The parser takes a sequence of tokens and builds a parse tree,
AST (Abstract Syntax Tree) according to the Erlang grammar.
This AST is then what the compiler compiles into executable
(virtual machine) code.

#### The Tokenizer

The tokenizer is simple.  It stems from the tool *lex*
that try a bunch of regular expressions on the input and when one
matches it becomes a token and is removed from the input.
Rinse and repeat.

The tokenizer is no longer that simple, but it doesn't keep
much state and looks just a few fixed number of characters ahead
in the input.

For example; from the start state, if the tokenizer sees
a «`'`» character, it switches state to scanning a quoted atom.
While doing so it translate escape sequences such as «`\n`»
(into ASCII 10) and when it sees a «`'`» character it produces
an atom token and goes back to the start state.

### Problems with simple prefixes

All of these simple prefixes has to become separate tokens in the tokenizer:
«`bf"`» would constitute the start token for a binary string
with interpolation syntax.  So would «`bf"""`», «`b"`», «`b"""`»,
and so on.

The tokenizer would have to know of all combinations of prefix characters
and emit distinct tokens for every combination.

Today, the character sequence «`b`», «`f`», «`"`» is scanned as a token
for the atom «`bf`» followed by the string start token «`"`».
That combination fails in the parser so it is syntactically invalid today,
which is what makes simple prefixes a possible language extension.

A simple prefix approach would have to scan a number of characters
ahead to distinguish between an atom followed by string start
vs. prefixed string start, and it would be a different number
of characters depending on which atom characters that have
been found so far.  This is rather messy.

Furthermore, it is likely that we want the feature of choosing
[String Delimiters][], especially for regular expressions such as:

    re(^"+.*/.*$)

Among the desired delimiters are «`/`» and «`<`»+«`>`».  The currently
valid code «`b<X`» meaning atom «`b`» less than «`X`», would instead
have to be interpreted as prefixed string start «`b<`» with «`X`»
being the first string content character.

For the «`/`» character we run into similar problems with for example
«`b/X`», which would be a run-time error today, but if we also would
want capital letter prefixes, then «`B/X`» is perfectly valid today
but would become a string start.

There are more likely problems with simple string prefixes:
«`#bf{`» is today the start of a record named «`bf`», and is
scanned as punctuation character «`#`», atom «`bf`» and separator «`{`»,
which the parser sorts out to be a record start.

With simple prefix characters the tokenizer would have to be rewritten
to recognize «`#bf`» as a new record token, a rewrite that might cause
unexpected changes in record handling.  For example, today, «`# bf {`»
is also a valid record start, so to be completely compatible the tokenizer
would have to allow white-space or even newlines within the new record
token, between «`#`» and the atom characters, which would be really ugly...

For other reasons, namely that function call parenthesis are optional
, Elixir has chosen to use the «`~`» character as the start of
a string prefix which they call a "[Sigil][1]".

Having a distinct start character for this feature simplifies
tokenizing and parsing.

### Sigil

In a general sense, a [Sigil][3], is a prefix to a variable
that indicates its type, such as «`$I`» in Basic or Perl,
where «`$`» is the sigil and «`I`» is the variable.

Here we define a Sigil as a prefix to a string literal
that indicates how to interpret the string literal.
It consists of:

1. The character «`~`»
2. The [Sigil Type][], which is a name composed of a sequence of
   characters that are allowed as the second or later characters
   in a variable or an atom.  In short ISO [Latin-1][] letters, digits,
   «`_`» and «`@`».  The [Sigil Type][] may be empty, also known as
   the [Empty Sigil][].

### Sigil Type

The parser, the compiler, parse transforms and higher level utilities
make use of the [Sigil Type][], for example to convert a string into
a UTF-8 encoded binary, or pre-compile a regular expression.

The suggested Sigil Types, inherited from Elixir, are:

* «`s`»: string in Elixir, `unicode:unicode_binary()` in Erlang,
  a string represented as a UTF-8 encoded binary
* «`c`»: character list, `string()` in Erlang, a list of Unicode codepoints
* «`r`»: regular expression, `unicode:charlist()` in Erlang,
  to be used as the input to regular expression compilation.
  How to handle regular expressions should be subject to another EEP,
  but it should be possible to pass the fact that a string contains
  a regular expression up to for example the code loader
  that can pre-compile regular expressions in load time.
  The [Sigil Suffix][] can be interpreted as character flags
  to the regular expression compilation.

### String Delimiters

Immediately following the [Sigil][] is the string start delimiter.
A specific start delimiter character has a corresponding
end delimiter character.

The allowed delimiter start-end character pairs are:
«`()`», «`[]`», «`{}`», and «`<>`».

The following characters are both start and end delimiters:
«`/`», «`|`», «`#`», «`` ` ``», «`@`»,  «`'`», and «`"`».

Triple-quote delimiters are also allowed, that is; a sequence of
3 or more «`"`» characters with newlines and indentation
as described in [EEP 64][].

### String Content

Between the start and end [String Delimiters][], all characters
are string content.

The delimiters «`'`» and «`"`» work as they do for quoted atoms
and regular strings which allow escape sequences in the string content.

All other delimiters do not allow escape sequences; all characters
are verbatim up to the end delimiter, and there is no way
to escape the end delimiter.

For the odd case that none of the verbatim delimiters can be used,
it is always possible to use the «`'`» or «`"`» delimiters
and quote all «`\`» characters, or to use a triple-quoted (or more)
string since that in theory always allow choosing a delimiter
that cannot be found in the string content.

### Sigil Suffix

Immediately following the String Content comes the Sigil Suffix,
that may be empty.

The Sigil Suffix consists, as the [Sigil Type][] in the [Sigil][] prefix,
of name characters, and may be empty.

The Sigil Suffix may contain information about how to interpret
the String Content, for a specific [Sigil Type][].  For example;
regular expressions can make use of suffix flag characters to control
regexp compilation such as the «`i`» flag for a character case
insensitive regular expression.

Another thing the Sigil Suffix can be used for is to tell the parser
to do variable interpolation of the string.  Say, a suffix
«`v`» on [Sigil Type][] «`s`» or «`c`» makes the parser scan
for sequences like «`~Var`», and rewrite the parse tree to do
stringifying of `Var` and concatenation of the string pieces.

#### The Empty Sigil

The Empty Sigil (default [Sigil Type][]) should either be disallowed,
like in Elixir, or implement the most desired use case.

This EEP suggests that it should be «`s`», which is to create
a UTF-8 encoded binary.

So «`~"abc"`» should be equivalent to «`<<"abc"/utf8>>`».

### Comparison with Elixir

The [Empty Sigil][] is not allowed in Elixir.

The delimiters «`#`», «`` ` ``» and «`@`» are not allowed in Elixir.

The [Sigil Type][]s «`s`», «`c`», and «`r`», would behave the same
in both Erlang and Elixir, but in Elixir it is if the [Sigil Type][]
is uppercase or lowercase that specifies if the string content
allows escape sequences or not.  This EEP proposes that the choice of
delimiters specify that.

When Elixir allows escape sequences it also allows expression interpolation
in strings.  This EEP avoids the topic of general expression interpolation.

There are small differences in which escape sequences that are implemented
in the languages; Elixir allows escaping of newlines, and has got
an escape sequence «`\a`», which Erlang does not.

There are also small differences in how newlines are handled
between heredocs in Elixir and triple-quoted strings in Erlang.
See [EEP 64][].

In [Elixir][1], adding a «`~s`» sigil to a regular string or a heredoc
creates an equivalent string.

In Erlang, since strings are character lists, it is instead adding a «`~c`»
sigil to a regular string or a triple-quoted string, that would create
an equivalent string *except* that the sigil string could implement
variable interpolation.

Details about regular expression sigils, «`~r`», in particular
their [Sigil Suffix][]es remains to be decided in Erlang.

It has not been decided how or even *if* expression interpolation
in strings will be implemented in Erlang, nor if variable interpolation
could be implemented instead.

Reference Implementation
------------------------

[PR-7684][] Implements the basics of handling Sigils on string literals.
The tokenizer produces a «`sigil`» token before the string literal, and a
«`sigil_suffix`» token after.  These are then removed by the parser.

Another approach would be to produce e.g a «`sigil_string`» token
for the whole string and then handle that in the parser.
It would require more state to be kept in the tokenizer between
the parts of the sigil prefixed string, and therefore need
more tokenizer rewriting.

[1]:     https://elixir-lang.org/getting-started/sigils.html
         "The Elixir Programming Language: Getting Started - Sigils"

[2]:     https://github.com/erlang/eep/pull/45
         "String Interpolation Syntax"

[3]:     https://en.wikipedia.org/wiki/Sigil_(computer_programming)
         "Wikipedia: Sigils"

[EEP 64]:     https://www.erlang.org/eeps/eep-0064.md
              "EEP 64: Triple-Quoted Strings"

[Latin-1]:    https://en.wikipedia.org/wiki/ISO/IEC_8859-1
              "Wikipedia: ISO-IEC 8859-1"

[PR-7684]:    https://github.com/erlang/otp/pull/7684
              "Sigils on String Literals"

[Abstract]:             #abstract
                        "Abstract"

[Sigil]:                #sigil
                        "Sigil"

[Sigil Type]:           #sigil-type
                        "Sigil Type"

[String Delimiters]:    #string-delimiters
                        "String Delimiters"

[4]:                    #string-delimiters
                        "String Delimiters"

[Sigil Suffix]:         #sigil-suffix
                        "Sigil Suffix"

[Empty Sigil]:          #empty-sigil
                        "Empty Sigil"

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.

[EmacsVar]: <> "Local Variables:"
[EmacsVar]: <> "mode: indented-text"
[EmacsVar]: <> "indent-tabs-mode: nil"
[EmacsVar]: <> "sentence-end-double-space: t"
[EmacsVar]: <> "fill-column: 70"
[EmacsVar]: <> "coding: utf-8"
[EmacsVar]: <> "End:"
[VimVar]: <> " vim: set fileencoding=utf-8 expandtab shiftwidth=4 softtabstop=4: "
