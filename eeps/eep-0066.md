    Author: Raimo Niskanen <raimo(at)erlang(dot)org>
    Status: Draft
    Type: Standards Track
    Created: 25-Sep-2023
    Erlang-Version: OTP-27
    Post-History:
****
EEP 65: Sigils for String Literals
----

Abstract
========

This EEP proposes Sigils for string literals very much like
[Elixir Sigils][1].  The chief reason is to facilitate other suggested
language features,  many of which exists in Elixir under the umbrella of
[Sigils][1], such as:

* [String Interpolation Syntax][2]
* Regular Expression Syntax
* Choice of string delimiters
* Binary Strings; `unicode:unicode_binary()`
* Verbatim Strings
* Escape sequences in [Triple-Quoted Strings][EEP 64] (multi-line strings)

Rationale
=========

Many existing suggestions listed in the [Abstract][]
use a prefix before a normal erlang string such as:

    u"For UTF-8 encoded binary strings"

or

    bf"For UTF-8 encoded binary with interpolation formatting: ~foo()~"

This EEP suggests using the same or very similar syntax as in Elixir
for [Sigils][3] on literal strings to avoid syntactical problems with
simple prefixes, and to not make these sibling languages deviate
too much without good reason:

    ~s"For UTF-8 encoded binary with interpolation formatting: ~foo()~"

Design Decisions
----------------

In the following text double angle quotation marks are used to
highlight source code characters.  For example: «`.`» means
the dot character (full stop).

### Erlang Language Structure (Tokenizer and Parser)

The Erlang programming language is built according to a traditional
tokenizer+parser+compiler model.

The tokenizer a.k.a scanner a.k.a lexer scans the source code
character sequence and converts into a sequence of Tokens,
like atom, variable, string, integer, reserved word,
punctuation character or operator:
«`atom`», «`Variable`», «`"string"`», «`123`», «*case*», «`:`» and «`++`».

The parser takes a sequence of tokens and builds a parse tree,
AST (Abstract Syntax Tree) according to the Erlang grammar.
This AST is then what the compiler compiles into executable
(virtual machine) code.

#### The Tokenizer

The tokenizer is simple.  It stems from the tool *lex*
that try a bunch of regular expressions on the input and when one
matches it becomes a token and is removed from the input.
Rinse and repeat.

The tokenizer is no longer that simple, but it doesn't keep
much state and looks just a few fixed number of characters ahead
in the input.

For example; from the start state, if the tokenizer sees
a «`'`» character, it switches state to scanning a quoted atom.
While doing so it translate escape sequences such as «`\n`»
(into ASCII 10) and when it sees a «`'`» character it produces
an atom token and goes back to the start state.

### Problems with simple prefixes

All of these simple prefixes has to become separate tokens in the tokenizer:
«`bf"`» would constitute the start token for a binary string
with interpolation syntax.  So would «`bf"""`», «`b"`», «`b"""`»,
and so on.

The tokenizer would have to know of all combinations of prefix characters
and emit distinct tokens for every combination.

Today, the character sequence «`b`», «`f`», «`"`» is scanned as a token
for the atom «`bf`» followed by the string start token «`"`».
That combination fails in the parser so it is syntactically invalid today,
which is what makes simple prefixes a possible language extension.

A simple prefix approach would have to scan a number of characters
ahead to distinguish between an atom followed by string start
vs. prefixed string start, and it would be a different number
of characters depending on which atom characters that have
been found so far.  This is rather messy.

Furthermore, it is likely that we want the feature of choosing
[String Delimiters][], especially for regular expressions such as:

    re(^"+.*/.*$)

Among the desired delimiters are «`/`» and «`<`»+«`>`».  The currently
valid code «`b<X`» meaning atom «`b`» less than «`X`», would instead
have to be interpreted as prefixed string start «`b<`» with «`X`»
being the first string content character.

For the «`/`» character we run into similar problems with for example
«`b/X`», which would be a run-time error today, but if we also would
want capital letter prefixes, then «`B/X`» is perfectly valid today
but would become a string start.

There are more likely problems with simple string prefixes:
«`#bf{`» is today the start of a record named «`bf`», and is
scanned as punctuation character «`#`», atom «`bf`» and separator «`{`»,
which the parser sorts out to be a record start.

With simple prefix characters the tokenizer would have to be rewritten
to recognize «`#bf`» as a new record token, a rewrite that might cause
unexpected changes in record handling.  For example, today, «`# bf {`»
is also a valid record start, so to be completely compatible the tokenizer
would have to allow white-space or even newlines within the new record
token, between «`#`» and the atom characters, which would be really ugly...

For reasons, maybe some of them above, Elixir has chosen to use
the «`~`» character as the start of a string prefix which they
call a ["Sigil"][1].

### Sigil

In a general sense, a [Sigil][3], is a prefix to a variable
that indicates its type, such as «`$I`» in Basic or Perl,
 where «`$`» is the sigil and «`I`» is the variable.

Here we define a Sigil as a prefix to a string literal
that indicates how to interpret the string literal.
It consists of:

1. The character «`~`»
2. An (optional) character in the range «`a`»-«`z`» or «`A`»-«`Z`»,
   that specifies the [Sigil Type][].  The Sigil Type can
   affect how the String Content is scanned, for example
   if escape sequences are honoured.

### String Delimiters

Immediately following the [Sigil][] is the string start delimiter.
A start delimiter has a corresponding end delimiter.

The allowed delimiter start-end character pairs are:
«`()`», «`[]`», «`{}`», and «`<>`».

The following characters are both start and end delimiters:
«`/`», «`|`», «`'`», and «`"`».  Triple-quote delimiters are also allowed,
that is, a sequence of 3 or more «`"`» characters with newlines
as described in [EEP 64][].

### String Content

Between the start and end [String Delimiters][], all characters
are string content.  In a triple-quoted string all characters
are verbatim.  In a string with single-character [String Delimiters][],
normal Erlang escape sequences prefixed with «`\`» are honoured.
The [Sigil Type][] can change this behaviour.

Also, string interpolation should be performed for some [Sigil Type][]s.

### Sigil Suffix

After the String Content comes the end [delimiter][String Delimiters],
and immediately after that the Sigil Suffix, that may be empty.

The Sigil Suffix is a sequence of "name" characters, that is, those that
are allowed as the second or later character in a variable or an atom.
These are in short ISO [Latin-1][] letters, digits, «`_`» and «`@`».

The Sigil Suffix may contain information about how to interpret
the String Content, for a specific Sigil Type.  For example;
regular expressions can make use of suffix flags to control
expression compilation such as the «`i`» flag for a character case
insensitive regular expression.

### Sigil Type

The suggested Sigil Types, inherited from Elixir, are:

* «`s`»: `unicode:unicode_binary()`, a string represented
  as a UTF-8 encoded binary
* «`c`»: `string()`, an Erlang string, a.k.a character list
  (Unicode codepoint list)
* «`r`»: regular expression, pre-compiled.
  [Sigil Suffix][]es such as in Elixir: «`u`», «`i`», «`s`», «`m`»,
  «`x`», «`f`» and «`U`», should be implemented as flags to
  the regular expression compilation.  Since Erlang is in the process of
  changing its regular expression engine, these flags need an overhaul.

All those Sigil Types allow both escape sequences and string interpolation.

The capital letter Sigil Types «`S`», «`C`» and «`R`» are
siblings to the above but takes the String Content verbatim as in
do not handle escape sequences nor string interpolation.

#### The Empty Sigil

The Empty Sigil (default [Sigil Type][]) should either be disallowed,
like in Elixir, or implement the most desired use case,
which might be one of:

* Shorthand for today's `unicode:unicode_binary()`s:
  «`~"Content"`» equivalent to «`<<"Content"/utf8>>`»
* Regular strings with choice of [String Delimiters][]:
  «`~{"Content"}`» equivalent to «`"\"Content\""`»
* Equivalent to «`~s`»
* Equivalent to «`~c`»

The first two can be implemented today without deciding on
the matter of string interpolation.

### Comparison with Elixir

The [Empty Sigil][] is not allowed in Elixir.

All suggested [Sigil Type][]s in this proposal: «`s`», «`S`», «`c`», «`C`»,
«`r`», and «`R`», would behave the same in both Erlang and Elixir
with respect to escape sequences and string interpolation.  There is,
however, small differences in which escape sequences that are implemented
in the languages; Elixir allows escaping of newlines, and has got
an escape sequence «`\a`», which Erlang does not.

There are also small differences in how newlines are handled
between heredocs in Elixir and triple-quoted strings in Erlang.
See [EEP 64][].

In [Elixir][1], adding a «`~s`» sigil to a regular string or a heredoc
creates an equivalent string.

According to this suggestion, since strings are character lists
in Erlang, instead adding a «`~c`» sigil to a regular string
or a triple-quoted string, would create an equivalent string
*except* that the sigil string should implement string interpolation.

Details about regular expression sigils, «`~r`» and «`~R`», in particular
their [Sigil Suffix][]es remains to be decided, so they might differ.

It has not been decided how or even *if* string interpolation will
be implemented in Erlang, so it surely might differ.

Reference Implementation
------------------------

[PR-7684][] Implements the basics of handling Sigils on string literals.
The tokenizer produces a «`sigil`» token before the string literal, and a
«`sigil_suffix`» token after.  These are then removed by the parser.

Another approach would be to produce e.g a «`sigil_string`» token
for the whole string and then handle that in the parser.
It would require more state to be kept in the tokenizer between
the parts of the sigil prefixed string, and therefore need
more tokenizer rewriting.

[1]:     https://elixir-lang.org/getting-started/sigils.html
         "The Elixir Programming Language: Getting Started - Sigils"

[2]:     https://github.com/erlang/eep/pull/45
         "String Interpolation Syntax"

[3]:     https://en.wikipedia.org/wiki/Sigil_(computer_programming)
         "Wikipedia: Sigils"

[EEP 64]:     https://www.erlang.org/eeps/eep-0064.md
              "EEP 64: Triple-Quoted Strings"

[Latin-1]:    https://en.wikipedia.org/wiki/ISO/IEC_8859-1
              "Wikipedia: ISO-IEC 8859-1"

[PR-7684]:    https://github.com/erlang/otp/pull/7684
              "Sigils on String Literals"

[Abstract]:             #abstract
                        "Abstract"

[Sigil]:                #sigil
                        "Sigil"

[Sigil Type]:           #sigil-type
                        "Sigil Type"

[String Delimiters]:    #string-delimiters
                        "String Delimiters"

[Sigil Suffix]:         #sigil-suffix
                        "Sigil Suffix"

[Empty Sigil]:          #empty-sigil
                        "Empty Sigil"

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.

[EmacsVar]: <> "Local Variables:"
[EmacsVar]: <> "mode: indented-text"
[EmacsVar]: <> "indent-tabs-mode: nil"
[EmacsVar]: <> "sentence-end-double-space: t"
[EmacsVar]: <> "fill-column: 70"
[EmacsVar]: <> "coding: utf-8"
[EmacsVar]: <> "End:"
[VimVar]: <> " vim: set fileencoding=utf-8 expandtab shiftwidth=4 softtabstop=4: "
